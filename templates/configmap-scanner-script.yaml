# Scanner Scripts ConfigMap - ENHANCED with Intelligent Version Detection and Policy Gating
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "bd-selfscan.name" . }}-scanner-scripts
  namespace: {{ .Values.global.namespace }}
  labels:
    {{- include "bd-selfscan.labels" . | nindent 4 }}
    app.kubernetes.io/component: scanner-scripts
  annotations:
    description: "Enhanced scanner scripts for BD SelfScan container vulnerability scanning with intelligent version detection and per-application policy gating"
    bd-selfscan/config-type: "scripts"
    bd-selfscan/version: "{{ .Chart.AppVersion | default .Chart.Version }}"
    bd-selfscan/features: "intelligent-version-detection,explicit-overrides,auto-detection,latest-tag-fix,policy-gating,per-application-enforcement"
data:
  # ENHANCED: Core BDSC Container scanning engine with intelligent version detection (v2.0.0)
  # Features: Fixes FAILURE_BLACKDUCK_FEATURE_ERROR, handles "latest" tag conversion, 9 detection strategies
  bdsc-container-scan.sh: |
    {{- .Files.Get "scripts/bdsc-container-scan.sh" | nindent 4 }}
  
  # ENHANCED: Single application wrapper with projectVersion support and Policy Gating (v2.1.0)
  # Features: Reads projectVersion from config, supports explicit overrides, auto-detection, per-app policy enforcement
  scan-application.sh: |
    #!/bin/bash
    # BD SelfScan Single Application Scanner - ENHANCED VERSION with Policy Gating
    # 
    # Purpose: Wrapper script that scans a single application by name from configuration
    # Features: Enhanced version detection with explicit override support + Per-Application Policy Gating
    # Usage: ./scan-application.sh "Application Name"
    #        ./scan-application.sh "App Name" "namespace" "labelSelector" "projectGroup"
    #
    # Version: 2.1.0 with intelligent version detection and policy gating
    # Author: BD SelfScan Team

    set -euo pipefail

    # Script metadata
    readonly SCRIPT_NAME="$(basename "$0")"
    readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    readonly SCRIPT_VERSION="2.1.0"

    # Default configuration
    export CONFIG_FILE="${CONFIG_FILE:-/config/applications.yaml}"
    export DEBUG_ENABLED="${DEBUG_ENABLED:-false}"
    export APPLICATION_NAME=""

    # Color codes for logging (if terminal supports it)
    if [[ -t 2 ]]; then
        readonly RED='\033[0;31m'
        readonly GREEN='\033[0;32m'
        readonly YELLOW='\033[1;33m'
        readonly BLUE='\033[0;34m'
        readonly PURPLE='\033[0;35m'
        readonly CYAN='\033[0;36m'
        readonly NC='\033[0m'
    else
        readonly RED=''
        readonly GREEN=''
        readonly YELLOW=''
        readonly BLUE=''
        readonly PURPLE=''
        readonly CYAN=''
        readonly NC=''
    fi

    # Logging functions with enhanced formatting
    log_info() {
        echo -e "${BLUE}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" >&2
    }

    log_success() {
        echo -e "${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" >&2
    }

    log_warning() {
        echo -e "${YELLOW}[WARNING]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" >&2
    }

    log_error() {
        echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" >&2
    }

    log_debug() {
        if [[ "$DEBUG_ENABLED" == "true" ]]; then
            echo -e "${PURPLE}[DEBUG]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" >&2
        fi
    }

    log_section() {
        echo "" >&2
        echo -e "${CYAN}$*${NC}" >&2
        echo "" >&2
    }

    # Function to display script usage
    show_usage() {
        cat << EOF
    BD SelfScan Single Application Scanner v${SCRIPT_VERSION}
    Scans a single application by name from configuration with enhanced version detection and policy gating.

    USAGE:
        $SCRIPT_NAME "Application Name"
        $SCRIPT_NAME "App Name" "namespace" "labelSelector" "projectGroup"

    PARAMETERS:
        Application Name    - Name of application from applications.yaml (required)
        namespace          - Override namespace (optional)  
        labelSelector      - Override label selector (optional)
        projectGroup       - Override project group (optional)

    ENVIRONMENT VARIABLES:
        APP_NAME           - Alternative to CLI argument for application name
        CONFIG_FILE        - Path to applications.yaml (default: /config/applications.yaml)
        DEBUG_ENABLED      - Enable debug logging (true/false, default: false)
        BD_URL             - Black Duck server URL (required)
        BD_TOKEN           - Black Duck API token (required)
        TRUST_CERT         - Trust SSL certificates (default: true)

    EXAMPLES:
        $SCRIPT_NAME "OWASP WebGoat"
        $SCRIPT_NAME "Production API" "prod-ns" "app=api-gateway" "Production Services"
        
        export APP_NAME="Development App"
        $SCRIPT_NAME

    VERSION DETECTION:
        - If projectVersion is specified in config: Uses exact version
        - If projectVersion not specified: Auto-detects from container image tags
        - Handles problematic tags like 'latest' intelligently

    POLICY GATING (NEW):
        - Per-application policy enforcement control
        - policyGating: true/false (enable/disable enforcement)
        - policyGatingRisk: severity levels that cause failures
        - Discovery mode vs. enforcement mode per application

    EXIT CODES:
        0  - Success
        1  - Configuration error or application not found
        2  - Validation failure  
        3  - Scanning failure
        9  - Policy violation failure (when enforcement enabled)

    EOF
    }

    # ENHANCED: Function to read application configuration with projectVersion AND policy gating support
    read_application_config() {
        local app_name="$1"
        
        if [[ ! -f "$CONFIG_FILE" ]]; then
            log_error "Configuration file not found: $CONFIG_FILE"
            log_info "Expected configuration file locations:"
            log_info "  - /config/applications.yaml (default)"
            log_info "  - Set CONFIG_FILE environment variable to custom location"
            return 1
        fi
        
        log_info "Loading configuration for application: $app_name"
        
        # Validate YAML syntax
        if ! yq e '.' "$CONFIG_FILE" >/dev/null 2>&1; then
            log_error "Configuration file contains invalid YAML syntax"
            return 1
        fi
        
        # Check if application exists in configuration
        if ! yq e ".applications[] | select(.name == \"$app_name\")" "$CONFIG_FILE" >/dev/null 2>&1; then
            log_error "Application '$app_name' not found in configuration"
            log_info "Available applications:"
            local available_apps
            if available_apps=$(yq e '.applications[].name' "$CONFIG_FILE" 2>/dev/null); then
                echo "$available_apps" | sed 's/^/  - /' >&2
            else
                log_info "  (Cannot read configuration - check YAML syntax)"
            fi
            return 1
        fi
        
        # Read configuration values with error handling
        export TARGET_NS=$(yq e ".applications[] | select(.name == \"$app_name\") | .namespace" "$CONFIG_FILE" 2>/dev/null)
        export LABEL_SELECTOR=$(yq e ".applications[] | select(.name == \"$app_name\") | .labelSelector" "$CONFIG_FILE" 2>/dev/null) 
        export DESIRED_PROJECT_GROUP=$(yq e ".applications[] | select(.name == \"$app_name\") | .projectGroup" "$CONFIG_FILE" 2>/dev/null)
        export PROJECT_TIER=$(yq e ".applications[] | select(.name == \"$app_name\") | .projectTier // 3" "$CONFIG_FILE" 2>/dev/null)
        export PROJECT_PHASE=$(yq e ".applications[] | select(.name == \"$app_name\") | .projectPhase // \"DEVELOPMENT\"" "$CONFIG_FILE" 2>/dev/null)
        
        # ENHANCED: Read project version configuration with override support
        local configured_version
        configured_version=$(yq e ".applications[] | select(.name == \"$app_name\") | .projectVersion // \"\"" "$CONFIG_FILE" 2>/dev/null)
        
        # Handle project version configuration
        if [[ -n "$configured_version" ]] && [[ "$configured_version" != "null" ]] && [[ "$configured_version" != '""' ]]; then
            # Explicit version override specified
            export BD_PROJECT_VERSION_OVERRIDE="$configured_version"
            export BD_VERSION_SOURCE="config"
            log_info "Using explicit project version from config: $BD_PROJECT_VERSION_OVERRIDE"
        else
            # No explicit version - enable auto-detection
            export BD_PROJECT_VERSION_OVERRIDE=""
            export BD_VERSION_SOURCE="auto"
            log_info "No explicit project version configured - will auto-detect from container image tags"
        fi
        
        # NEW: Read per-application policy gating configuration
        local policy_gating
        local policy_gating_risk
        policy_gating=$(yq e ".applications[] | select(.name == \"$app_name\") | .policyGating // false" "$CONFIG_FILE" 2>/dev/null)
        policy_gating_risk=$(yq e ".applications[] | select(.name == \"$app_name\") | .policyGatingRisk // \"\"" "$CONFIG_FILE" 2>/dev/null)
        
        # Process policy gating settings
        log_section "=== Policy Gating Configuration ==="
        if [[ "$policy_gating" == "true" && -n "$policy_gating_risk" && "$policy_gating_risk" != "null" && "$policy_gating_risk" != '""' ]]; then
            # Per-application policy enforcement enabled with explicit severities
            export POLICY_FAIL_SEVERITIES="$policy_gating_risk"
            log_info "Policy gating ENABLED for '$app_name'"
            log_info "  Policy severities: $POLICY_FAIL_SEVERITIES"
            log_info "  Scan will FAIL on violations of: $POLICY_FAIL_SEVERITIES"
            log_info "  Build/deployment will be BLOCKED on policy violations"
        elif [[ "$policy_gating" == "true" ]]; then
            # Policy gating enabled but no severities specified - use tier defaults
            case "$PROJECT_TIER" in
                1) export POLICY_FAIL_SEVERITIES="BLOCKER,CRITICAL,HIGH";;
                2) export POLICY_FAIL_SEVERITIES="BLOCKER,CRITICAL";;
                3) export POLICY_FAIL_SEVERITIES="BLOCKER,CRITICAL";;
                4) export POLICY_FAIL_SEVERITIES="BLOCKER";;
                *) export POLICY_FAIL_SEVERITIES="BLOCKER,CRITICAL";;
            esac
            log_info "Policy gating ENABLED for '$app_name' (using Tier $PROJECT_TIER defaults)"
            log_info "  Policy severities: $POLICY_FAIL_SEVERITIES"
            log_warning "  Recommendation: Explicitly set policyGatingRisk in configuration"
            log_info "  Build/deployment will be BLOCKED on policy violations"
        else
            # Policy gating disabled - discovery mode only
            unset POLICY_FAIL_SEVERITIES 2>/dev/null || true
            export POLICY_FAIL_SEVERITIES=""
            log_info "Policy gating DISABLED for '$app_name' (discovery mode)"
            log_info "  Scan results will be reported to Black Duck but never fail"
            log_info "  Build/deployment will NEVER be blocked by security findings"
            log_info "  Perfect for discovery phase or non-critical applications"
        fi
        
        # Read optional description
        local app_description
        app_description=$(yq e ".applications[] | select(.name == \"$app_name\") | .description // \"\"" "$CONFIG_FILE" 2>/dev/null)
        if [[ -n "$app_description" ]] && [[ "$app_description" != "null" ]]; then
            export APPLICATION_DESCRIPTION="$app_description"
        fi
        
        # Validate required fields
        if [[ -z "$TARGET_NS" ]] || [[ "$TARGET_NS" == "null" ]]; then
            log_error "Missing or invalid namespace for application '$app_name'"
            return 1
        fi
        
        if [[ -z "$LABEL_SELECTOR" ]] || [[ "$LABEL_SELECTOR" == "null" ]]; then
            log_error "Missing or invalid labelSelector for application '$app_name'"
            return 1
        fi
        
        if [[ -z "$DESIRED_PROJECT_GROUP" ]] || [[ "$DESIRED_PROJECT_GROUP" == "null" ]]; then
            log_error "Missing or invalid projectGroup for application '$app_name'"
            return 1
        fi
        
        # Validate PROJECT_PHASE against allowed values
        case "${PROJECT_PHASE}" in
            PLANNING|DEVELOPMENT|PRERELEASE|RELEASED|DEPRECATED|ARCHIVED)
                log_debug "Valid project phase: $PROJECT_PHASE"
                ;;
            *)
                log_warning "Invalid PROJECT_PHASE '$PROJECT_PHASE', using DEVELOPMENT as default"
                export PROJECT_PHASE="DEVELOPMENT"
                ;;
        esac
        
        # Validate PROJECT_TIER
        if [[ ! "$PROJECT_TIER" =~ ^[1-4]$ ]]; then
            log_warning "Invalid PROJECT_TIER '$PROJECT_TIER', using 3 as default"
            export PROJECT_TIER="3"
        fi
        
        # Validate policy gating risk severities if specified
        if [[ -n "${POLICY_FAIL_SEVERITIES:-}" ]]; then
            local valid_severities="BLOCKER CRITICAL HIGH MEDIUM LOW TRIVIAL UNSPECIFIED ALL NONE"
            IFS=',' read -ra severity_array <<< "$POLICY_FAIL_SEVERITIES"
            for severity in "${severity_array[@]}"; do
                severity=$(echo "$severity" | tr '[:lower:]' '[:upper:]' | xargs) # Normalize and trim
                if [[ ! " $valid_severities " =~ " $severity " ]]; then
                    log_warning "Invalid policy severity '$severity' - will be ignored"
                fi
            done
        fi
        
        log_success "Configuration loaded successfully"
        log_section "=== Application Configuration Summary ==="
        log_info "  Application: $app_name"
        log_info "  Namespace: $TARGET_NS"
        log_info "  Label Selector: $LABEL_SELECTOR" 
        log_info "  Project Group: $DESIRED_PROJECT_GROUP"
        log_info "  Project Tier: $PROJECT_TIER"
        log_info "  Project Phase: $PROJECT_PHASE"
        log_info "  Version Strategy: $BD_VERSION_SOURCE"
        if [[ "$BD_VERSION_SOURCE" == "config" ]]; then
            log_info "  Explicit Version: $BD_PROJECT_VERSION_OVERRIDE"
        else
            log_info "  Version Detection: Auto-detect from image tags"
        fi
        if [[ -n "${POLICY_FAIL_SEVERITIES:-}" ]]; then
            log_info "  Policy Enforcement: ENABLED ($POLICY_FAIL_SEVERITIES)"
        else
            log_info "  Policy Enforcement: DISABLED (discovery mode)"
        fi
        if [[ -n "${APPLICATION_DESCRIPTION:-}" ]]; then
            log_info "  Description: $APPLICATION_DESCRIPTION"
        fi
        
        # Debug output
        if [[ "$DEBUG_ENABLED" == "true" ]]; then
            log_debug "Application data: $(yq e ".applications[] | select(.name == \"$app_name\")" "$CONFIG_FILE" 2>/dev/null)"
        fi
        
        return 0
    }

    # ENHANCED: Function to execute the container scan with policy gating support
    execute_scan() {
        local app_name="${1:-unknown}"
        
        log_section "=== Starting Container Scan ==="
        log_info "Application: $app_name"
        log_info "Namespace: $TARGET_NS"
        log_info "Label Selector: $LABEL_SELECTOR"
        log_info "Project Group: $DESIRED_PROJECT_GROUP"
        if [[ -n "${POLICY_FAIL_SEVERITIES:-}" ]]; then
            log_info "Policy Enforcement: ENABLED (fail on: $POLICY_FAIL_SEVERITIES)"
        else
            log_info "Policy Enforcement: DISABLED (discovery mode)"
        fi

        # Find the core scanner script
        local scanner_script="/scripts/bdsc-container-scan.sh"
        if [[ ! -f "$scanner_script" ]]; then
            # Try alternative locations
            if [[ -f "$SCRIPT_DIR/bdsc-container-scan.sh" ]]; then
                scanner_script="$SCRIPT_DIR/bdsc-container-scan.sh"
            else
                log_error "Core scanner script not found: bdsc-container-scan.sh"
                log_info "Expected locations:"
                log_info "  - /scripts/bdsc-container-scan.sh"
                log_info "  - $SCRIPT_DIR/bdsc-container-scan.sh"
                return 1
            fi
        fi

        # Ensure scanner script is executable
        if [[ ! -x "$scanner_script" ]]; then
            log_info "Making scanner script executable..."
            chmod +x "$scanner_script" || {
                log_error "Failed to make scanner script executable"
                return 1
            }
        fi

        # Set up environment for the scanner (including policy gating settings)
        export BD_URL="${BD_URL:-}"
        export BD_TOKEN="${BD_TOKEN:-}"
        export TRUST_CERT="${TRUST_CERT:-true}"
        export DEBUG_ENABLED="${DEBUG_ENABLED:-false}"
        
        # CRITICAL: Export the application name for proper project naming
        export APPLICATION_NAME="$app_name"
        
        # NEW: Policy gating environment variable is already set by read_application_config
        # POLICY_FAIL_SEVERITIES is exported with per-application settings

        # Validate required environment variables
        if [[ -z "$BD_URL" ]] || [[ -z "$BD_TOKEN" ]]; then
            log_error "Black Duck credentials not configured"
            log_info "Required environment variables:"
            log_info "  BD_URL    - Black Duck server URL"
            log_info "  BD_TOKEN  - Black Duck API token"
            log_info "Please set these environment variables or check your secrets configuration"
            return 1
        fi

        log_info "Executing container scan with enhanced policy controls..."
        log_debug "Scanner script: $scanner_script"
        log_debug "Policy enforcement: ${POLICY_FAIL_SEVERITIES:-'DISABLED (discovery mode)'}"

        # Execute the scanner with proper error handling
        local start_time end_time duration exit_code=0
        start_time=$(date +%s)

        if "$scanner_script"; then
            end_time=$(date +%s)
            duration=$((end_time - start_time))
            
            # Enhanced success logging with policy context
            if [[ -n "${POLICY_FAIL_SEVERITIES:-}" ]]; then
                log_success "Container scan completed successfully (${duration}s) - Policy enforcement PASSED"
                log_info "No policy violations found at severity levels: $POLICY_FAIL_SEVERITIES"
            else
                log_success "Container scan completed successfully (${duration}s) - Discovery mode"
                log_info "Scan results reported to Black Duck for visibility"
            fi
            return 0
        else
            exit_code=$?
            end_time=$(date +%s)
            duration=$((end_time - start_time))
            
            # Enhanced error handling with policy context
            if [[ -n "${POLICY_FAIL_SEVERITIES:-}" ]]; then
                log_error "Container scan failed (${duration}s, exit code: $exit_code) - Policy enforcement FAILED"
                log_error "Policy violations found at severity levels: $POLICY_FAIL_SEVERITIES"
                log_info "To disable policy enforcement for this application:"
                log_info "  Set policyGating: false in applications.yaml for '$app_name'"
                log_info "To make policy enforcement more lenient:"
                log_info "  Adjust policyGatingRisk (e.g., 'BLOCKER' only) in applications.yaml"
            else
                log_error "Container scan failed (${duration}s, exit code: $exit_code) - Technical failure in discovery mode"
            fi
            
            # Provide troubleshooting guidance based on exit code
            case $exit_code in
                11)
                    log_error "FAILURE_BLACKDUCK_FEATURE_ERROR - Black Duck feature licensing issue"
                    log_info "Troubleshooting steps:"
                    log_info "  1. Verify Black Duck licensing (CONTAINER_ANALYSIS, BDSC)"
                    log_info "  2. Check if project version is valid (not 'latest' or empty)"
                    log_info "  3. Verify Black Duck server version compatibility"
                    ;;
                9)
                    log_error "FAILURE_POLICY_VIOLATION - Security policy violations detected"
                    if [[ -n "${POLICY_FAIL_SEVERITIES:-}" ]]; then
                        log_info "Policy enforcement is ENABLED for severity levels: $POLICY_FAIL_SEVERITIES"
                        log_info "Options to resolve:"
                        log_info "  1. Fix the security vulnerabilities in your application"
                        log_info "  2. Set policyGating: false to switch to discovery mode"
                        log_info "  3. Adjust policyGatingRisk to be more lenient (e.g., 'BLOCKER' only)"
                        log_info "  4. Create security exceptions in Black Duck for accepted risks"
                    else
                        log_info "Unexpected policy failure in discovery mode - check configuration"
                    fi
                    ;;
                1|2|3)
                    log_error "General scanning failure"
                    log_info "Check scanner logs for specific error details"
                    log_info "Enable DEBUG_ENABLED=true for detailed troubleshooting information"
                    ;;
                *)
                    log_error "Unexpected exit code: $exit_code"
                    log_info "Enable DEBUG_ENABLED=true for detailed troubleshooting information"
                    ;;
            esac
            
            return 3
        fi
    }

    # Function to parse command line arguments
    parse_arguments() {
        local app_name=""
        
        # Handle help request
        if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
            show_usage
            exit 0
        fi
        
        # Parse positional arguments
        case $# in
            0)
                # No arguments - check for environment variable
                app_name="${APP_NAME:-}"
                if [[ -z "$app_name" ]]; then
                    log_error "No application name provided"
                    log_info "Usage: $SCRIPT_NAME \"Application Name\""
                    log_info "   or: export APP_NAME=\"Application Name\" && $SCRIPT_NAME"
                    show_usage
                    return 1
                fi
                ;;
            1)
                # Single argument - application name
                app_name="$1"
                ;;
            *)
                log_error "Invalid number of arguments: $#"
                log_info "Expected: 0 or 1 arguments"
                show_usage
                return 1
                ;;
        esac
        
        # Validate application name
        if [[ -z "$app_name" ]]; then
            log_error "Application name cannot be empty"
            return 1
        fi
        
        # Set global variables
        export APPLICATION_NAME="$app_name"
        
        return 0
    }

    # Cleanup function
    cleanup() {
        local exit_code=$?
        
        # Clear sensitive environment variables
        unset BD_TOKEN 2>/dev/null || true
        
        if [[ $exit_code -eq 0 ]]; then
            log_success "Scan application completed successfully"
        elif [[ $exit_code -eq 9 ]]; then
            log_warning "Scan application completed with policy violations (exit code: $exit_code)"
        else
            log_warning "Scan application exited with code $exit_code"
        fi
        
        exit $exit_code
    }

    # Set trap for cleanup
    trap cleanup EXIT INT TERM

    # Main function
    main() {
        log_section "=== BD SelfScan - Single Application Scanner v${SCRIPT_VERSION} ==="
        log_info "Enhanced with per-application policy gating control"
        
        # Parse command line arguments
        if ! parse_arguments "$@"; then
            return 1
        fi
        
        log_info "Target application: $APPLICATION_NAME"
        log_debug "Debug mode enabled"
        
        # Read application configuration - now includes policy gating
        if ! read_application_config "$APPLICATION_NAME"; then
            return 1
        fi
        
        # Execute the container scan with policy gating support
        if ! execute_scan "$APPLICATION_NAME"; then
            return 3
        fi
        
        log_success "Single application scan completed successfully"
        return 0
    }

    # Script entry point
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        main "$@"
    fi
  
  # ENHANCED: Bulk application scanner with version reporting and policy gating support (v2.1.0)
  # Features: Shows version strategy and policy enforcement for each application, enhanced parallel scanning
  scan-all-applications.sh: |
    {{- .Files.Get "scripts/scan-all-applications.sh" | nindent 4 }}
  
  # ENHANCED: Common utility functions with version detection and policy support (v2.1.0)
  common-functions.sh: |
    {{- .Files.Get "scripts/common-functions.sh" | nindent 4 }}

  # ENHANCED: Health check script with version detection testing
  health-check.sh: |
    {{- .Files.Get "scripts/health-check.sh" | nindent 4 }}

  # ENHANCED: Container image discovery script with version preview
  discover-images.sh: |
    {{- .Files.Get "scripts/discover-images.sh" | nindent 4 }}

  # ENHANCED: Configuration testing and validation script
  test-config.sh: |
    {{- .Files.Get "scripts/test-config.sh" | nindent 4 }}

  # NEW: Policy gating testing script
  test-policy-gating.sh: |
    #!/bin/bash
    # BD SelfScan Policy Gating Testing Script v1.0.0
    # Purpose: Test per-application policy gating configuration and behavior
    set -euo pipefail
    
    # Source common functions
    source /scripts/common-functions.sh 2>/dev/null || {
        echo "[ERROR] Cannot load common functions"
        exit 1
    }
    
    CONFIG_FILE="${1:-/config/applications.yaml}"
    TEST_MODE="${2:-preview}"  # preview, dry-run, or live
    
    log_section "=== BD SelfScan Policy Gating Testing v1.0.0 ==="
    log_info "Configuration file: $CONFIG_FILE"
    log_info "Test mode: $TEST_MODE"
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "Configuration file not found: $CONFIG_FILE"
        exit 1
    fi
    
    # Get application count
    APP_COUNT=$(yq eval '.applications | length' "$CONFIG_FILE" 2>/dev/null || echo "0")
    log_info "Found $APP_COUNT applications to test"
    
    if [[ $APP_COUNT -eq 0 ]]; then
        log_error "No applications defined in configuration"
        exit 1
    fi
    
    # Test each application's policy configuration
    ENFORCEMENT_APPS=()
    DISCOVERY_APPS=()
    POLICY_ERRORS=0
    
    for i in $(seq 0 $((APP_COUNT - 1))); do
        APP_NAME=$(yq eval ".applications[$i].name" "$CONFIG_FILE")
        NAMESPACE=$(yq eval ".applications[$i].namespace" "$CONFIG_FILE")
        POLICY_GATING=$(yq eval ".applications[$i].policyGating // false" "$CONFIG_FILE")
        POLICY_GATING_RISK=$(yq eval ".applications[$i].policyGatingRisk // \"\"" "$CONFIG_FILE")
        PROJECT_TIER=$(yq eval ".applications[$i].projectTier // 3" "$CONFIG_FILE")
        
        log_section "Testing Policy Configuration: $APP_NAME"
        
        # Policy configuration analysis
        if [[ "$POLICY_GATING" == "true" ]]; then
            ENFORCEMENT_APPS+=("$APP_NAME")
            
            if [[ -n "$POLICY_GATING_RISK" && "$POLICY_GATING_RISK" != "null" && "$POLICY_GATING_RISK" != '""' ]]; then
                log_info "✓ Policy enforcement ENABLED with explicit severities: $POLICY_GATING_RISK"
                
                # Validate severity values
                VALID_SEVERITIES="BLOCKER CRITICAL HIGH MEDIUM LOW TRIVIAL UNSPECIFIED ALL NONE"
                IFS=',' read -ra SEVERITY_ARRAY <<< "$POLICY_GATING_RISK"
                INVALID_SEVERITIES=()
                
                for severity in "${SEVERITY_ARRAY[@]}"; do
                    severity=$(echo "$severity" | xargs | tr '[:lower:]' '[:upper:]')
                    if [[ ! " $VALID_SEVERITIES " =~ " $severity " ]]; then
                        INVALID_SEVERITIES+=("$severity")
                    fi
                done
                
                if [[ ${#INVALID_SEVERITIES[@]} -gt 0 ]]; then
                    log_error "Invalid policy severities: ${INVALID_SEVERITIES[*]}"
                    ((POLICY_ERRORS++))
                fi
                
            else
                # Using tier defaults
                case "$PROJECT_TIER" in
                    1) TIER_POLICY="BLOCKER,CRITICAL,HIGH";;
                    2) TIER_POLICY="BLOCKER,CRITICAL";;
                    3) TIER_POLICY="BLOCKER,CRITICAL";;
                    4) TIER_POLICY="BLOCKER";;
                    *) TIER_POLICY="BLOCKER,CRITICAL";;
                esac
                log_info "✓ Policy enforcement ENABLED using Tier $PROJECT_TIER defaults: $TIER_POLICY"
                log_warning "Recommendation: Set explicit policyGatingRisk for clarity"
            fi
        else
            DISCOVERY_APPS+=("$APP_NAME")
            log_info "✓ Policy enforcement DISABLED (discovery mode)"
            
            if [[ -n "$POLICY_GATING_RISK" && "$POLICY_GATING_RISK" != "null" && "$POLICY_GATING_RISK" != '""' ]]; then
                log_warning "policyGatingRisk '$POLICY_GATING_RISK' will be ignored (policyGating: false)"
            fi
        fi
        
        # Test namespace access if not in preview mode
        if [[ "$TEST_MODE" != "preview" ]]; then
            if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
                if check_namespace_access "$NAMESPACE"; then
                    log_success "Namespace '$NAMESPACE' accessible"
                else
                    log_error "Cannot access namespace '$NAMESPACE'"
                    ((POLICY_ERRORS++))
                fi
            else
                log_error "Namespace '$NAMESPACE' does not exist"
                ((POLICY_ERRORS++))
            fi
        fi
    done
    
    # Summary and recommendations
    log_section "=== Policy Gating Test Results ==="
    log_info "Total applications: $APP_COUNT"
    log_info "Enforcement enabled: ${#ENFORCEMENT_APPS[@]}"
    log_info "Discovery mode: ${#DISCOVERY_APPS[@]}"
    log_info "Configuration errors: $POLICY_ERRORS"
    
    if [[ ${#ENFORCEMENT_APPS[@]} -gt 0 ]]; then
        log_info ""
        log_info "Applications with policy enforcement:"
        for app in "${ENFORCEMENT_APPS[@]}"; do
            log_info "  - $app"
        done
        log_info ""
        log_info "These applications will:"
        log_info "  ✓ Report vulnerabilities to Black Duck"
        log_info "  ✓ FAIL scans on policy violations"  
        log_info "  ✓ BLOCK builds/deployments when violations found"
    fi
    
    if [[ ${#DISCOVERY_APPS[@]} -gt 0 ]]; then
        log_info ""
        log_info "Applications in discovery mode:"
        for app in "${DISCOVERY_APPS[@]}"; do
            log_info "  - $app"
        done
        log_info ""
        log_info "These applications will:"
        log_info "  ✓ Report vulnerabilities to Black Duck"
        log_info "  ✓ Always succeed regardless of findings"
        log_info "  ✓ Never block builds/deployments"
    fi
    
    # Policy migration recommendations
    log_section "=== Policy Migration Recommendations ==="
    
    if [[ ${#DISCOVERY_APPS[@]} -eq $APP_COUNT ]]; then
        log_info "All applications in discovery mode - good for initial rollout"
        log_info "Next steps:"
        log_info "  1. Review scan results in Black Duck for baseline understanding"
        log_info "  2. Enable enforcement on low-risk applications first"
        log_info "  3. Use 'BLOCKER' only for initial enforcement"
        log_info "  4. Gradually tighten policies based on application criticality"
        
    elif [[ ${#ENFORCEMENT_APPS[@]} -eq $APP_COUNT ]]; then
        log_info "All applications have policy enforcement - mature security posture"
        log_info "Monitor for:"
        log_info "  1. Excessive scan failures blocking development"
        log_info "  2. Need for security exceptions in Black Duck"  
        log_info "  3. Policy tuning based on false positives"
        
    else
        log_info "Mixed enforcement model - balanced approach"
        log_info "Continue with:"
        log_info "  1. Gradual migration of discovery apps to enforcement"
        log_info "  2. Monitor enforcement apps for policy effectiveness"
        log_info "  3. Adjust policies based on business risk tolerance"
    fi
    
    # Test execution recommendations
    if [[ "$TEST_MODE" == "preview" ]]; then
        log_info ""
        log_info "Test Execution Options:"
        log_info "  Preview mode (current): Configuration analysis only"
        log_info "  Dry-run mode: $0 $CONFIG_FILE dry-run"
        log_info "  Live test mode: $0 $CONFIG_FILE live"
        
    elif [[ "$TEST_MODE" == "dry-run" ]]; then
        log_info ""
        log_info "Dry-run completed - no actual scans performed"
        log_info "To test with actual scans: $0 $CONFIG_FILE live"
        
    elif [[ "$TEST_MODE" == "live" ]]; then
        if [[ $POLICY_ERRORS -eq 0 ]]; then
            log_success "Configuration validation passed - ready for live scanning"
            log_info "To run scans: /scripts/scan-all-applications.sh"
        else
            log_error "Fix configuration errors before running live scans"
        fi
    fi
    
    # Exit with appropriate code
    if [[ $POLICY_ERRORS -eq 0 ]]; then
        log_success "Policy gating testing completed successfully"
        exit 0
    else
        log_error "Policy gating testing completed with $POLICY_ERRORS errors"
        exit 1
    fi

  # NEW: Policy enforcement simulation script
  simulate-policy-enforcement.sh: |
    #!/bin/bash
    # BD SelfScan Policy Enforcement Simulation Script v1.0.0
    # Purpose: Simulate policy enforcement behavior without running actual scans
    set -euo pipefail
    
    source /scripts/common-functions.sh 2>/dev/null || {
        echo "[ERROR] Cannot load common functions"
        exit 1
    }
    
    APP_NAME="${1:-}"
    SIMULATE_FINDINGS="${2:-moderate}"  # none, low, moderate, high, critical
    
    if [[ -z "$APP_NAME" ]]; then
        log_error "Usage: $0 <application_name> [simulate_findings]"
        log_info "Examples:"
        log_info "  $0 'OWASP WebGoat' critical"
        log_info "  $0 'Production API' moderate"
        log_info "  $0 'Dev Tool' none"
        exit 1
    fi
    
    log_section "=== Policy Enforcement Simulation ==="
    log_info "Application: $APP_NAME"
    log_info "Simulated findings: $SIMULATE_FINDINGS"
    
    CONFIG_FILE="/config/applications.yaml"
    
    # Read policy configuration for the application
    if ! yq e ".applications[] | select(.name == \"$APP_NAME\")" "$CONFIG_FILE" >/dev/null 2>&1; then
        log_error "Application '$APP_NAME' not found in configuration"
        exit 1
    fi
    
    POLICY_GATING=$(yq e ".applications[] | select(.name == \"$APP_NAME\") | .policyGating // false" "$CONFIG_FILE")
    POLICY_GATING_RISK=$(yq e ".applications[] | select(.name == \"$APP_NAME\") | .policyGatingRisk // \"\"" "$CONFIG_FILE")
    PROJECT_TIER=$(yq e ".applications[] | select(.name == \"$APP_NAME\") | .projectTier // 3" "$CONFIG_FILE")
    
    # Determine effective policy severities
    if [[ "$POLICY_GATING" == "true" ]]; then
        if [[ -n "$POLICY_GATING_RISK" && "$POLICY_GATING_RISK" != "null" && "$POLICY_GATING_RISK" != '""' ]]; then
            EFFECTIVE_POLICY="$POLICY_GATING_RISK"
        else
            case "$PROJECT_TIER" in
                1) EFFECTIVE_POLICY="BLOCKER,CRITICAL,HIGH";;
                2) EFFECTIVE_POLICY="BLOCKER,CRITICAL";;
                3) EFFECTIVE_POLICY="BLOCKER,CRITICAL";;
                4) EFFECTIVE_POLICY="BLOCKER";;
                *) EFFECTIVE_POLICY="BLOCKER,CRITICAL";;
            esac
        fi
        ENFORCEMENT_MODE="ENABLED"
    else
        EFFECTIVE_POLICY=""
        ENFORCEMENT_MODE="DISABLED"
    fi
    
    log_info "Policy enforcement: $ENFORCEMENT_MODE"
    if [[ "$ENFORCEMENT_MODE" == "ENABLED" ]]; then
        log_info "Policy severities: $EFFECTIVE_POLICY"
    fi
    
    # Simulate vulnerability findings
    log_section "=== Simulated Vulnerability Scan Results ==="
    
    case "$SIMULATE_FINDINGS" in
        none)
            log_success "No vulnerabilities found"
            FOUND_BLOCKER=false
            FOUND_CRITICAL=false
            FOUND_HIGH=false
            ;;
        low)
            log_info "Found vulnerabilities: LOW (3), TRIVIAL (7)"
            FOUND_BLOCKER=false
            FOUND_CRITICAL=false
            FOUND_HIGH=false
            ;;
        moderate)
            log_warning "Found vulnerabilities: MEDIUM (2), LOW (5), TRIVIAL (10)"
            FOUND_BLOCKER=false
            FOUND_CRITICAL=false
            FOUND_HIGH=false
            ;;
        high)
            log_warning "Found vulnerabilities: HIGH (1), MEDIUM (3), LOW (8)"
            FOUND_BLOCKER=false
            FOUND_CRITICAL=false
            FOUND_HIGH=true
            ;;
        critical)
            log_error "Found vulnerabilities: CRITICAL (2), HIGH (1), MEDIUM (4), LOW (12)"
            FOUND_BLOCKER=false
            FOUND_CRITICAL=true
            FOUND_HIGH=true
            ;;
        blocker)
            log_error "Found vulnerabilities: BLOCKER (1), CRITICAL (3), HIGH (2), MEDIUM (6)"
            FOUND_BLOCKER=true
            FOUND_CRITICAL=true
            FOUND_HIGH=true
            ;;
        *)
            log_error "Invalid simulation mode: $SIMULATE_FINDINGS"
            log_info "Valid modes: none, low, moderate, high, critical, blocker"
            exit 1
            ;;
    esac
    
    # Simulate policy enforcement decision
    log_section "=== Policy Enforcement Simulation ==="
    
    if [[ "$ENFORCEMENT_MODE" == "DISABLED" ]]; then
        log_info "Policy enforcement DISABLED - scan would always succeed"
        log_success "SIMULATION RESULT: SCAN PASSES (discovery mode)"
        log_info "All vulnerabilities reported to Black Duck for visibility"
        exit 0
    fi
    
    # Check if any found vulnerabilities match enforcement policy
    POLICY_VIOLATION=false
    VIOLATION_DETAILS=()
    
    IFS=',' read -ra POLICY_ARRAY <<< "$EFFECTIVE_POLICY"
    for severity in "${POLICY_ARRAY[@]}"; do
        severity=$(echo "$severity" | xargs | tr '[:lower:]' '[:upper:]')
        
        case "$severity" in
            BLOCKER)
                if [[ "$FOUND_BLOCKER" == "true" ]]; then
                    POLICY_VIOLATION=true
                    VIOLATION_DETAILS+=("BLOCKER severity violations found")
                fi
                ;;
            CRITICAL)
                if [[ "$FOUND_CRITICAL" == "true" ]]; then
                    POLICY_VIOLATION=true
                    VIOLATION_DETAILS+=("CRITICAL severity violations found")
                fi
                ;;
            HIGH)
                if [[ "$FOUND_HIGH" == "true" ]]; then
                    POLICY_VIOLATION=true
                    VIOLATION_DETAILS+=("HIGH severity violations found")
                fi
                ;;
        esac
    done
    
    # Report simulation result
    if [[ "$POLICY_VIOLATION" == "true" ]]; then
        log_error "SIMULATION RESULT: SCAN FAILS (policy violation)"
        log_error "Policy violations detected:"
        for violation in "${VIOLATION_DETAILS[@]}"; do
            log_error "  - $violation"
        done
        log_error "Build/deployment would be BLOCKED"
        log_info ""
        log_info "Resolution options:"
        log_info "  1. Fix vulnerabilities in the application"
        log_info "  2. Set policyGating: false for discovery mode"
        log_info "  3. Adjust policyGatingRisk to be more lenient"
        log_info "  4. Create security exceptions in Black Duck"
        exit 9  # Policy violation exit code
    else
        log_success "SIMULATION RESULT: SCAN PASSES (no policy violations)"
        log_info "All found vulnerabilities are below enforcement threshold"
        log_info "Build/deployment would proceed normally"
        exit 0
    fi
    