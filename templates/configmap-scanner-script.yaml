# Scanner Scripts ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "bd-selfscan.name" . }}-scanner-scripts
  namespace: {{ .Values.global.namespace }}
  labels:
    {{- include "bd-selfscan.labels" . | nindent 4 }}
    app.kubernetes.io/component: scanner-scripts
  annotations:
    description: "Scanner scripts for BD SelfScan container vulnerability scanning"
    bd-selfscan/config-type: "scripts"
    bd-selfscan/version: "{{ .Chart.AppVersion | default .Chart.Version }}"
data:
  # Core BDSC Container scanning engine - CORRECTED VERSION with TAR export
  bdsc-container-scan.sh: |
    {{- .Files.Get "scripts/bdsc-container-scan.sh" | nindent 4 }}
  
  # Single application wrapper - UPDATED VERSION with APPLICATION_NAME export
  scan-application.sh: |
    {{- .Files.Get "scripts/scan-application.sh" | nindent 4 }}
  
  # Bulk application scanner - COMPLETE VERSION with enhanced features
  scan-all-applications.sh: |
    {{- .Files.Get "scripts/scan-all-applications.sh" | nindent 4 }}
  
  # Common utility functions (optional)
  common-functions.sh: |
    #!/bin/bash
    # Common utility functions for BD SelfScan scripts
    
    # Color codes for consistent logging
    export RED='\033[0;31m'
    export GREEN='\033[0;32m'
    export YELLOW='\033[1;33m'
    export BLUE='\033[0;34m'
    export PURPLE='\033[0;35m'
    export CYAN='\033[0;36m'
    export NC='\033[0m'
    
    # Common logging functions
    log_info() { 
        echo -e "${BLUE}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1" >&2
    }
    
    log_success() { 
        echo -e "${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1" >&2
    }
    
    log_warning() { 
        echo -e "${YELLOW}[WARNING]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1" >&2
    }
    
    log_error() { 
        echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1" >&2
    }
    
    log_debug() { 
        [[ "${DEBUG_ENABLED:-false}" == "true" ]] && echo -e "${PURPLE}[DEBUG]${NC} $(date '+%Y-%m-%d %H:%M:%S') $1" >&2
    }
    
    log_section() { 
        echo -e "\n${CYAN}$1${NC}" >&2
    }
    
    # Validation functions
    validate_kubernetes_name() {
        local name="$1"
        if [[ ! "$name" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]]; then
            return 1
        fi
        return 0
    }
    
    validate_label_selector() {
        local selector="$1"
        # Basic validation - could be enhanced
        if [[ -z "$selector" ]]; then
            return 1
        fi
        return 0
    }
    
    # Environment validation
    check_required_env() {
        local vars=("$@")
        local missing=()
        
        for var in "${vars[@]}"; do
            if [[ -z "${!var:-}" ]]; then
                missing+=("$var")
            fi
        done
        
        if [[ ${#missing[@]} -gt 0 ]]; then
            log_error "Missing required environment variables: ${missing[*]}"
            return 1
        fi
        
        return 0
    }
    
    # Kubernetes helper functions
    wait_for_pod_ready() {
        local namespace="$1"
        local label_selector="$2"
        local timeout="${3:-300}"
        
        log_info "Waiting for pods to be ready: namespace=$namespace, selector=$label_selector"
        
        if kubectl wait --for=condition=ready pod \
           -l "$label_selector" \
           -n "$namespace" \
           --timeout="${timeout}s" >/dev/null 2>&1; then
            return 0
        else
            return 1
        fi
    }
    
    get_pod_images() {
        local namespace="$1"
        local label_selector="$2"
        
        kubectl get pods -n "$namespace" -l "$label_selector" -o jsonpath='{.items[*].spec.containers[*].image}' 2>/dev/null | tr ' ' '\n' | sort -u | grep -v '^$'
    }
    
    # Image validation
    validate_image_format() {
        local image="$1"
        
        # Basic image format validation
        if [[ ! "$image" =~ ^[a-zA-Z0-9._/-]+:[a-zA-Z0-9._-]+$ ]] && \
           [[ ! "$image" =~ ^[a-zA-Z0-9._/-]+@sha256:[a-f0-9]{64}$ ]]; then
            return 1
        fi
        
        return 0
    }
    
    # Black Duck helper functions
    test_blackduck_connectivity() {
        local bd_url="$1"
        local bd_token="$2"
        local trust_cert="${3:-true}"
        
        local curl_args=("-s" "--connect-timeout" "10" "--max-time" "30")
        
        if [[ "$trust_cert" == "true" ]]; then
            curl_args+=("--insecure")
        fi
        
        local health_url="$bd_url/api/current-version"
        
        if curl "${curl_args[@]}" -H "Authorization: token $bd_token" "$health_url" >/dev/null 2>&1; then
            return 0
        else
            return 1
        fi
    }
    
    # Cleanup functions
    cleanup_temp_files() {
        local temp_dir="${1:-/tmp/bd-selfscan}"
        
        if [[ "${KEEP_TEMP_FILES:-false}" == "true" ]]; then
            log_info "Keeping temporary files for debugging: $temp_dir"
            return 0
        fi
        
        if [[ -d "$temp_dir" ]]; then
            log_info "Cleaning up temporary files: $temp_dir"
            rm -rf "$temp_dir" 2>/dev/null || true
        fi
    }
    
    # Signal handlers
    setup_signal_handlers() {
        trap 'log_warning "Script interrupted by signal"; cleanup_temp_files; exit 130' INT TERM
        trap 'log_error "Unexpected error at line $LINENO"' ERR
    }
    
    # Resource monitoring
    check_disk_space() {
        local path="${1:-/tmp}"
        local required_gb="${2:-10}"
        
        local available_kb
        available_kb=$(df "$path" | awk 'NR==2 {print $4}')
        local available_gb=$((available_kb / 1024 / 1024))
        
        if [[ $available_gb -lt $required_gb ]]; then
            log_warning "Low disk space: ${available_gb}GB available, ${required_gb}GB required"
            return 1
        fi
        
        return 0
    }
    
    # Timeout function
    run_with_timeout() {
        local timeout_seconds="$1"
        shift
        
        timeout "$timeout_seconds" "$@"
        return $?
    }
    
    # Project name sanitization for Black Duck
    sanitize_project_name() {
        local name="$1"
        
        # Replace invalid characters and ensure valid format
        echo "$name" | sed 's/[^a-zA-Z0-9 ._-]//g' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    }
    
    # Version string normalization
    normalize_version() {
        local version="$1"
        
        # Handle common version formats
        echo "$version" | sed 's/^v//' | sed 's/[^a-zA-Z0-9.-]/_/g'
    }
    
    log_info "Common functions loaded successfully"

  # Health check script for debugging
  health-check.sh: |
    #!/bin/bash
    # BD SelfScan Health Check Script
    set -euo pipefail
    
    # Source common functions
    source /scripts/common-functions.sh 2>/dev/null || true
    
    log_section "=== BD SelfScan Health Check ==="
    
    # Check environment
    log_info "Checking environment variables..."
    if check_required_env BD_URL BD_TOKEN; then
        log_success "Required environment variables are set"
    else
        log_error "Missing required environment variables"
        exit 1
    fi
    
    # Check tools
    log_info "Checking required tools..."
    local tools=("java" "kubectl" "yq" "jq" "skopeo" "curl")
    local missing_tools=()
    
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    
    if [[ ${#missing_tools[@]} -eq 0 ]]; then
        log_success "All required tools are available"
    else
        log_error "Missing tools: ${missing_tools[*]}"
        exit 1
    fi
    
    # Check Black Duck connectivity
    log_info "Testing Black Duck connectivity..."
    if test_blackduck_connectivity "$BD_URL" "$BD_TOKEN" "${TRUST_CERT:-true}"; then
        log_success "Black Duck server is reachable"
    else
        log_error "Cannot reach Black Duck server"
        exit 1
    fi
    
    # Check configuration
    log_info "Checking configuration..."
    if [[ -f "/config/applications.yaml" ]]; then
        if yq eval '.' /config/applications.yaml >/dev/null 2>&1; then
            local app_count
            app_count=$(yq eval '.applications | length' /config/applications.yaml 2>/dev/null || echo "0")
            log_success "Configuration valid: $app_count applications configured"
        else
            log_error "Invalid YAML syntax in configuration"
            exit 1
        fi
    else
        log_error "Configuration file not found: /config/applications.yaml"
        exit 1
    fi
    
    # Check disk space
    log_info "Checking disk space..."
    if check_disk_space "/tmp" 5; then
        log_success "Sufficient disk space available"
    else
        log_warning "Low disk space - scans may fail"
    fi
    
    log_success "Health check completed successfully"

  # Container image discovery script
  discover-images.sh: |
    #!/bin/bash
    # Container Image Discovery Script
    set -euo pipefail
    
    source /scripts/common-functions.sh 2>/dev/null || true
    
    NAMESPACE="${1:-}"
    LABEL_SELECTOR="${2:-}"
    
    if [[ -z "$NAMESPACE" ]] || [[ -z "$LABEL_SELECTOR" ]]; then
        log_error "Usage: $0 <namespace> <label-selector>"
        exit 1
    fi
    
    log_info "Discovering images in namespace: $NAMESPACE"
    log_info "Label selector: $LABEL_SELECTOR"
    
    # Get images from pods
    if images=$(get_pod_images "$NAMESPACE" "$LABEL_SELECTOR"); then
        if [[ -n "$images" ]]; then
            log_success "Found container images:"
            echo "$images" | while read -r image; do
                if validate_image_format "$image"; then
                    echo "  ✓ $image"
                else
                    echo "  ⚠ $image (invalid format)"
                fi
            done
        else
            log_warning "No container images found"
            exit 1
        fi
    else
        log_error "Failed to discover images"
        exit 1
    fi
    